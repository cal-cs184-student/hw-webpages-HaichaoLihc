<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CS184 HW1 Write-Up</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;700&family=Source+Serif+4:opsz,wght@8..60,500;8..60,700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f4f6f8;
        --panel: #ffffff;
        --ink: #1f2937;
        --muted: #5b6472;
        --line: #d6dde6;
        --accent: #0f6d7a;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "IBM Plex Sans", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 15% 10%, #dde8ef 0, transparent 38%),
          radial-gradient(circle at 85% 5%, #e8f0e0 0, transparent 35%),
          var(--bg);
      }

      .container {
        width: min(1080px, 94vw);
        margin: 42px auto;
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 14px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
      }

      .hero {
        padding: 28px;
        margin-bottom: 22px;
      }

      h1,
      h2,
      h3 {
        font-family: "Source Serif 4", serif;
        margin: 0;
      }

      h1 {
        font-size: clamp(1.9rem, 4vw, 2.4rem);
        text-align: center;
      }

      .meta {
        margin-top: 14px;
        text-align: center;
        color: var(--muted);
        line-height: 1.6;
      }

      .meta a {
        color: var(--accent);
      }

      section {
        padding: 24px;
        margin-bottom: 18px;
      }

      h2 {
        font-size: 1.55rem;
        margin-bottom: 12px;
        border-bottom: 1px solid var(--line);
        padding-bottom: 8px;
      }

      h3 {
        font-size: 1.1rem;
        margin: 18px 0 10px;
      }

      p,
      li {
        line-height: 1.65;
      }

      ul {
        margin: 10px 0 12px 20px;
      }

      .image-single {
        margin-top: 14px;
      }

      .image-grid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 14px;
      }

      .sample-rate-grid {
        grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
        gap: 18px;
      }

      figure {
        margin: 0;
      }

      img {
        width: 100%;
        display: block;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: #fff;
      }

      figcaption {
        margin-top: 6px;
        font-size: 0.93rem;
        color: var(--muted);
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header class="panel hero">
        <h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
        <div class="meta">
          <div><strong>Name:</strong> Haichao Li, Yuanbo Pang</div>
          <div>
            <strong>Webpage:</strong>
            <a href="https://cal-cs184-student.github.io/hw-webpages-HaichaoLihc/"
              >https://cal-cs184-student.github.io/hw-webpages-HaichaoLihc/</a
            >
          </div>
          <div>
            <strong>GitHub:</strong>
            <a href="https://github.com/cal-cs184-student/hw1-rasterizer-aaron"
              >https://github.com/cal-cs184-student/hw1-rasterizer-aaron</a
            >
          </div>
        </div>
      </header>

      <section class="panel">
        <h2>Overview</h2>
        <p>
          In this homework, I implemented a complete software rasterization pipeline
          across Tasks 1-6, and finished the creative extra credit (Task 7). The
          core work includes single-color triangle rasterization with robust inside
          tests, supersampling antialiasing, hierarchical transforms, barycentric
          interpolation for per-vertex color, texture mapping with nearest/bilinear
          pixel filtering, and mipmap-based level sampling for minification.
        </p>
        <p>
          I also added practical tooling for evaluation and write-up production,
          including reproducible render configurations for different sampling modes.
          For the extra credit submission, I generated an 800x800 procedural artwork
          using a C++ generator that emits many <code>colortri</code> primitives to
          build layered gradients and geometric swirl structures compatible with the
          course rasterizer.
        </p>
      </section>

      <section class="panel">
        <h2>Task 1: Drawing Single-Color Triangles</h2>
        <p>
          I rasterize triangles by first finding the triangle's bounding box
          (min/max x,y) and clamping it to the screen. Then I scan every pixel in
          that box and test the pixel center (x+0.5, y+0.5) with three edge
          functions. If all three edge values have the inside sign, I color that
          pixel. I update edge values incrementally across x/y, so each next test is
          just adds, and I write directly to <code>sample_buffer</code>.
        </p>
        <p>
          This is no worse than standard bounding-box sampling because it does the
          same amount of traversal: one pass over pixels inside the bounding box,
          with constant work per pixel. So time complexity is
          <code>O(bounding_box_width * bounding_box_height)</code>, same as any
          method that checks each sample in the triangle's bounding box.
        </p>

        <h3>Special optimizations (task 1 extra credit)</h3>
        <ul>
          <li>
            Because the edge function is affine in input x and y, I precompute
            coefficients and increment values at neighboring pixels instead of
            recomputing full expressions each sample.
          </li>
          <li>
            I determine winding sign once (from signed area), so the inside test uses
            a single consistent sign check.
          </li>
        </ul>

        <figure class="image-single">
          <img src="screenshot_2-17_0-42-0.png" alt="Task 1 triangle rasterization" />
          <figcaption>Task 1 rasterization result.</figcaption>
        </figure>

        <div class="image-grid">
          <figure>
            <img src="optimized.png" alt="Task 1 optimized" />
            <figcaption>Optimized version.</figcaption>
          </figure>
          <figure>
            <img src="unoptimized.png" alt="Task 1 unoptimized" />
            <figcaption>Unoptimized version.</figcaption>
          </figure>
        </div>
      </section>

      <section class="panel">
        <h2>Task 2: Antialiasing by Supersampling</h2>
        <h3>What I Did and How Supersampling Reduces Aliasing</h3>
        <ul>
          <li>For each triangle, I still find its bounding box.</li>
          <li>
            Let <code>N = sqrt(sample_rate)</code>. For each pixel
            <code>(x, y)</code> in that box, I evaluate an
            <code>N x N</code> grid of subpixel points at
            <code>(x + (i + 0.5)/N, y + (j + 0.5)/N)</code>.
          </li>
          <li>
            I run the same edge-function inside test at each subpixel position.
          </li>
          <li>
            If inside, I write that subpixel color into
            <code>sample_buffer</code>.
          </li>
          <li>
            After all rasterization is done, I average each pixel's samples and
            write that average to the final framebuffer in
            <code>resolve_to_framebuffer</code>.
          </li>
          <li>
            For boundary pixels, this average estimates the fraction of the pixel
            covered by the triangle (for example, around 6/16 coverage).
          </li>
          <li>
            With one sample, a boundary pixel becomes fully on or fully off, which
            creates sharp stair-step transitions between neighboring pixels.
          </li>
          <li>
            Supersampling converts those hard jumps into gradual intensity changes
            across edge pixels, so high-frequency jagged artifacts are reduced.
          </li>
        </ul>

        <h3>Data structure</h3>
        <ul>
          <li><code>sample_buffer</code> is a 1D array.</li>
          <li>Each pixel's samples are stored together.</li>
          <li>
            Pixel <code>(x, y)</code> starts at
            <code>(y * width + x) * sample_rate</code>.
          </li>
        </ul>

        <h3>Why supersampling helps</h3>
        <ul>
          <li>Single-sample drawing makes triangle edges look jagged.</li>
          <li>With many samples, edge pixels can be partly covered.</li>
          <li>Averaging those samples gives in-between colors on edges.</li>
          <li>This reduces the stair-step effect and smooths boundaries.</li>
        </ul>

        <h3>Pipeline changes</h3>
        <ul>
          <li>
            <code>set_sample_rate</code> and <code>set_framebuffer_target</code> now
            resize <code>sample_buffer</code> to
            <code>width * height * sample_rate</code>.
          </li>
          <li>
            <code>fill_pixel</code> now fills all samples of that pixel (for
            points/lines).
          </li>
          <li>
            <code>rasterize_triangle</code> now writes per-subsample instead of one
            color per pixel.
          </li>
          <li>
            <code>resolve_to_framebuffer</code> averages each pixel's samples into one
            final color.
          </li>
        </ul>

        <h3>Sample rate comparison (1, 4, 16)</h3>
        <div class="image-grid sample-rate-grid">
          <figure>
            <img src="screenshot_2-17_1-27-18.png" alt="Sample rate 1" />
            <figcaption>Sample rate = 1</figcaption>
          </figure>
          <figure>
            <img src="screenshot_2-17_1-27-20.png" alt="Sample rate 4" />
            <figcaption>Sample rate = 4</figcaption>
          </figure>
          <figure>
            <img src="screenshot_2-17_1-27-22.png" alt="Sample rate 16" />
            <figcaption>Sample rate = 16</figcaption>
          </figure>
        </div>
        <ul>
          <li>
            At sample rate 1, each edge pixel is decided by one center sample, so
            coverage is binary and jaggies are the strongest.
          </li>
          <li>
            At sample rate 4, pixels can represent partial coverage in larger steps,
            so edges become visibly smoother and thin features alias less.
          </li>
          <li>
            At sample rate 16, coverage is much finer, so edge transitions are even
            smoother; the gain is smaller than 1 to 4.
          </li>
          <li>
            The difference appears mainly along boundaries; fully inside/outside
            pixels look the same at all sample rates.
          </li>
          <li>
            Runtime and memory cost increase roughly linearly with
            <code>sample_rate</code> due to more sample tests, writes, and resolve
            work.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2>Task 3: Transforms</h2>
        <p>
          For Task 3, I modified <code>svg/transforms/robot.svg</code> so cubeman is
          waving instead of standing in a neutral pose. I used hierarchical
          transforms to rotate and reposition the limbs: the right arm is rotated
          sharply upward and the lower right arm is additionally bent to form a clear
          wave gesture. I then adjusted the left arm to angle downward slightly so
          the pose feels asymmetric and more natural.
        </p>
        <p>
          I also added small rotations to the legs with slight horizontal offsets to
          suggest a weight shift, making the character look balanced while waving
          rather than perfectly rigid.
        </p>

        <figure class="image-single">
          <img src="screenshot_2-17_2-11-16.png" alt="Waving cubeman" />
          <figcaption>Modified robot pose for Task 3.</figcaption>
        </figure>

        <h3>Task 3 Extra Credit: Viewport Rotation</h3>
        <p>
          I added a viewport-rotation feature with two keys: <strong>J</strong>
          rotates the view by +5 degrees and <strong>K</strong> rotates by -5
          degrees. To do this, I inserted one extra transform in the rendering
          pipeline. Before, points were mapped as SVG -> NDC -> screen; now they go
          SVG -> NDC -> rotated NDC -> screen.
        </p>
        <p>
          I rotate in NDC around the center (translate to x=0.5,y=0.5, then rotate,
          then translate back), so the whole scene rotates like a camera view while
          pan/zoom still behave normally. I also applied the same transform to the
          canvas border so it stays aligned with the SVG.
        </p>

        <figure class="image-single">
          <img src="screenshot_2-17_2-16-5.png" alt="Viewport rotation" />
          <figcaption>Viewport rotation extra credit.</figcaption>
        </figure>
      </section>

      <section class="panel">
        <h2>Task 4: Barycentric Coordinates</h2>
        <p>
          I implemented barycentric interpolation in
          <code>RasterizerImp::rasterize_interpolated_color_triangle(...)</code>.
          For each sample point in the triangle bounding box, I evaluate edge
          functions to determine inside/outside and convert them into barycentric
          weights. The interpolated color is then:
          <code>alpha * c0 + beta * c1 + gamma * c2</code>, where
          <code>alpha + beta + gamma = 1</code>.
        </p>
        <p>
          This gives a smooth color transition across triangle interiors and produces
          the expected color wheel visualization.
        </p>

        <figure class="image-single">
          <img src="task4_test7_sr1.png" alt="Task 4 test7 sample rate 1" />
          <figcaption>svg/basic/test7.svg at sample rate 1.</figcaption>
        </figure>
      </section>

      <section class="panel">
        <h2>Task 5: Pixel Sampling for Texture Mapping</h2>
        <p>
          I implemented texture mapping in
          <code>RasterizerImp::rasterize_textured_triangle(...)</code> by
          interpolating UV coordinates at each sample point and passing them to
          texture sampling. I implemented both
          <code>Texture::sample_nearest</code> and
          <code>Texture::sample_bilinear</code>, and selected between them via the
          pixel sampling mode (<code>P_NEAREST</code> vs <code>P_LINEAR</code>).
        </p>
        <p>
          Nearest sampling is faster but more jagged on high-frequency regions.
          Bilinear sampling blends neighboring texels and generally looks smoother.
          Increasing sample rate mainly helps geometric edge antialiasing.
        </p>

        <h3>Nearest vs Bilinear at 1 and 16 Samples Per Pixel</h3>
        <div class="image-grid sample-rate-grid">
          <figure>
            <img src="task5_nearest_sr1.png" alt="Task 5 nearest sr1" />
            <figcaption>P_NEAREST, sample rate = 1</figcaption>
          </figure>
          <figure>
            <img src="task5_nearest_sr16.png" alt="Task 5 nearest sr16" />
            <figcaption>P_NEAREST, sample rate = 16</figcaption>
          </figure>
          <figure>
            <img src="task5_bilinear_sr1.png" alt="Task 5 bilinear sr1" />
            <figcaption>P_LINEAR, sample rate = 1</figcaption>
          </figure>
          <figure>
            <img src="task5_bilinear_sr16.png" alt="Task 5 bilinear sr16" />
            <figcaption>P_LINEAR, sample rate = 16</figcaption>
          </figure>
        </div>
      </section>

      <section class="panel">
        <h2>Task 6: Level Sampling with Mipmaps</h2>
        <p>
          I extended texture sampling to support mip levels by implementing
          <code>Texture::sample</code> and <code>Texture::get_level</code>. For each
          shaded sample, I compute <code>p_uv</code>, <code>p_dx_uv</code>, and
          <code>p_dy_uv</code> in rasterization, then estimate level-of-detail from
          UV derivatives (scaled by base texture resolution).
        </p>
        <p>
          For this task I used my own texture image
          <code>img/img.png</code> through a custom SVG setup
          (<code>svg/texmap/task6_custom.svg</code>), then captured the four required
          combinations using the GUI screenshot hotkey.
        </p>
        <ul>
          <li><code>L_ZERO</code>: always sample mip level 0.</li>
          <li>
            <code>L_NEAREST</code>: compute level and sample the nearest mip level.
          </li>
          <li>
            <code>L_LINEAR</code>: interpolate between adjacent mip levels
            (trilinear when combined with <code>P_LINEAR</code>).
          </li>
        </ul>
        <p>
          Mipmap level sampling improves minification quality and reduces aliasing,
          at additional memory and computation cost.
        </p>

        <h3>Required Comparison Set</h3>
        <div class="image-grid sample-rate-grid">
          <figure>
            <img src="task6_lzero_pnearest.png" alt="Task 6 lzero pnearest" />
            <figcaption>L_ZERO + P_NEAREST</figcaption>
          </figure>
          <figure>
            <img src="task6_lzero_plinear.png" alt="Task 6 lzero plinear" />
            <figcaption>L_ZERO + P_LINEAR</figcaption>
          </figure>
          <figure>
            <img src="task6_lnearest_pnearest.png" alt="Task 6 lnearest pnearest" />
            <figcaption>L_NEAREST + P_NEAREST</figcaption>
          </figure>
          <figure>
            <img src="task6_lnearest_plinear.png" alt="Task 6 lnearest plinear" />
            <figcaption>L_NEAREST + P_LINEAR</figcaption>
          </figure>
        </div>

        <h3>Discussion and Tradeoffs</h3>
        <p>
          In this checker/stripe test image, the differences are clear in the
          high-frequency warped regions. <code>P_LINEAR</code> visibly smooths stripe
          boundaries, while <code>L_NEAREST</code> gives more stable detail than
          <code>L_ZERO</code> around the dense center pattern. The contrast becomes
          even more apparent with zoom-in and pixel inspection.
        </p>
        <ul>
          <li>
            Pixel sampling: <code>P_NEAREST</code> is faster; <code>P_LINEAR</code>
            gives smoother local texture transitions.
          </li>
          <li>
            Level sampling: <code>L_ZERO</code> is cheapest;
            <code>L_NEAREST</code>/<code>L_LINEAR</code> improve minification
            behavior.
          </li>
          <li>
            Sample rate: higher supersampling improves geometric edge antialiasing
            but increases time and sample buffer memory.
          </li>
          <li>
            Mipmaps increase texture memory (roughly about one-third extra for a full
            pyramid) in exchange for more stable texture filtering.
          </li>
        </ul>
      </section>

      <section class="panel">
        <h2>Task 7 (Extra Credit): Draw Something Creative</h2>
        <p>
          I created a procedural artwork and saved it as
          <code>docs/competition.svg</code> at 800x800 resolution.
        </p>

        <figure class="image-single">
          <img src="task7_competition_800.png" alt="Task 7 competition artwork" />
          <figcaption>Procedural competition artwork rendered by the rasterizer.</figcaption>
        </figure>

        <h3>How it was generated</h3>
        <p>
          I wrote a generator script at
          <code>src/generate_competition_svg.cpp</code>. The generator procedurally emits
          many <code>colortri</code> elements in three layers:
        </p>
        <ul>
          <li>
            A triangulated background grid that creates a smooth color gradient.
          </li>
          <li>
            A multi-band polar swirl where radius is modulated by sine/cosine terms,
            then tessellated into triangle strips.
          </li>
          <li>
            A central starburst accent made of additional triangles with varying hue.
          </li>
        </ul>
        <p>
          Colors are generated in HSV space and converted to RGB, producing continuous
          gradients and strong contrast while staying within primitives supported by
          this homework rasterizer.
        </p>
      </section>
    </div>
  </body>
</html>
